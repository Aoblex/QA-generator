[
    {
        "strategy": "subsection",
        "source": "machine_learning_chapter7",
        "title": "14.1.3 类与类之间的距离",
        "content_length": 3527,
        "content": "Title: 14.1.3 类与类之间的距离\nContent:\n下面考虑类 $G_{p}$ 与类 $G_{q}$ 之间的距离 $D(p, q)$, 也称为连接 (linkage)。类与类之间的距离也有多种定义。\n\n设类 $G_{p}$ 包含 $n_{p}$ 个样本, $G_{q}$ 包含 $n_{q}$ 个样本, 分别用 $\\bar{x}_{p}$ 和 $\\bar{x}_{q}$ 表示 $G_{p}$ 和 $G_{q}$ 的均值,即类的中心。\n\n(1) 最短距离或单连接 (single linkage)\n\n定义类 $G_{p}$ 的样本与类 $G_{q}$ 的样本之间的最短距离为两类之间的距离:\n\n\n\\begin{equation*}\nD_{p q}=\\min \\left\\{d_{i j} \\mid x_{i} \\in G_{p}, x_{j} \\in G_{q}\\right\\} \\tag{14.14}\n\\end{equation*}\n\n\n(2) 最长距离或完全连接 (complete linkage)\n\n定义类 $G_{p}$ 的样本与类 $G_{q}$ 的样本之间的最长距离为两类之间的距离:\n\n\n\\begin{equation*}\nD_{p q}=\\max \\left\\{d_{i j} \\mid x_{i} \\in G_{p}, x_{j} \\in G_{q}\\right\\} \\tag{14.15}\n\\end{equation*}\n\n\n(3) 中心距离\n\n定义类 $G_{p}$ 与类 $G_{q}$ 的中心 $\\bar{x}_{p}$ 与 $\\bar{x}_{q}$ 之间的距离为两类之间的距离:\n\n\n\\begin{equation*}\nD_{p q}=d_{\\bar{x}_{p} \\bar{x}_{q}} \\tag{14.16}\n\\end{equation*}\n\n\n(4) 平均距离\n\n定义类 $G_{p}$ 与类 $G_{q}$ 任意两个样本之间距离的平均值为两类之间的距离:\n\n\n\\begin{equation*}\nD_{p q}=\\frac{1}{n_{p} n_{q}} \\sum_{x_{i} \\in G_{p}} \\sum_{x_{j} \\in G_{q}} d_{i j} \\tag{14.17}\n\\end{equation*}\n\n\n\\section*{14.2 层次聚类}\n层次聚类假设类别之间存在层次结构, 将样本聚到层次化的类中。层次聚类又有聚合 (agglomerative) 或自下而上 (bottom-up) 聚类、分裂 (divisive) 或自上而下 (top-down) 聚\\\\\n类两种方法。因为每个样本只属于一个类, 所以层次聚类属于硬聚类。\n\n聚合聚类开始将每个样本各自分到一个类, 之后将相距最近的两类合并, 建立一个新的类, 重复此操作直到满足停止条件, 得到层次化的类别。分裂聚类开始将所有样本分到一个类, 之后将已有类中相距最远的样本分到两个新的类, 重复此操作直到满足停止条件, 得到层次化的类别。本书只介绍聚合聚类。\n\n聚合聚类的具体过程如下：对于给定的样本集合, 开始将每个样本分到一个类; 然后按照一定规则, 如类间距离最小, 将最满足规则条件的两个类进行合并; 如此反复进行, 每次减少一个类, 直到满足停止条件, 如所有样本聚为一类。\n\n由此可知, 聚合聚类需要预先确定下面三个要素:\n\n(1) 距离或相似度;\n\n(2) 合并规则;\n\n(3) 停止条件。\n\n根据这些要素的不同组合, 就可以构成不同的聚类方法。距离或相似度可以是闵可夫斯基距离、马哈拉诺比斯距离、相关系数、夹角余弦。合并规则一般是类间距离最小, 类间距离可以是最短距离、最长距离、中心距离、平均距离。停止条件可以是类的个数达到阈值（极端情况类的个数是 1)、类的直径超过阈值。\n\n如果采用欧氏距离为样本之间距离; 类间距离最小为合并规则, 其中最短距离为类间距离; 类的个数是 1, 即所有样本聚为一类为停止条件, 那么聚合聚类的算法如下。\n\n\\section*{算法 14.1 (聚合聚类算法)}\n输入: $n$ 个样本组成的样本集合及样本之间的距离。\n\n输出: 对样本集合的一个层次化聚类。\n\n(1) 计算 $n$ 个样本两两之间的欧氏距离 $\\left\\{d_{i j}\\right\\}$, 记作矩阵 $D=\\left[d_{i j}\\right]_{n \\times n}$ 。\n\n（2）构造 $n$ 个类，每个类只包含一个样本。\n\n(3) 合并类间距离最小的两个类, 其中最短距离为类间距离, 构建一个新类。\n\n(4) 计算新类与当前各类的距离。若类的个数为 1 , 终止计算, 否则, 回到步骤 (3)。可以看出聚合层次聚类算法的复杂度是 $O\\left(n^{3} m\\right)$, 其中 $m$ 是样本的维数, $n$ 是样本个数。下面通过一个例子说明聚合层次聚类算法。\n\n例 14.1 给定 5 个样本的集合, 样本之间的欧氏距离由如下矩阵 $D$ 表示:\n\n$$\nD=\\left[d_{i j}\\right]_{5 \\times 5}=\\left[\\begin{array}{ccccc}\n0 & 7 & 2 & 9 & 3 \\\\\n7 & 0 & 5 & 4 & 6 \\\\\n2 & 5 & 0 & 8 & 1 \\\\\n9 & 4 & 8 & 0 & 5 \\\\\n3 & 6 & 1 & 5 & 0\n\\end{array}\\right]\n$$\n\n其中 $d_{i j}$ 表示第 $i$ 个样本与第 $j$ 个样本之间的欧氏距离。显然 $D$ 为对称矩阵。应用聚合层次聚类法对这 5 个样本进行聚类。\n\n解 (1) 首先用 5 个样本构建 5 个类, $G_{i}=\\left\\{x_{i}\\right\\}, i=1,2, \\cdots, 5$, 这样, 样本之间的距离也就变成类之间的距离, 所以 5 个类之间的距离矩阵亦为 $D$ 。\n\n(2) 由矩阵 $D$ 可以看出, $D_{35}=D_{53}=1$ 为最小, 所以把 $G_{3}$ 和 $G_{5}$ 合并为一个新类, 记作 $G_{6}=\\left\\{x_{3}, x_{5}\\right\\}$ 。\n\n(3) 计算 $G_{6}$ 与 $G_{1}, G_{2}, G_{4}$ 之间的最短距离, 有\n\n$$\nD_{61}=2, \\quad D_{62}=5, \\quad D_{64}=5\n$$\n\n又注意到其余两类之间的距离是\n\n$$\nD_{12}=7, \\quad D_{14}=9, \\quad D_{24}=4\n$$\n\n显然, $D_{61}=2$ 最小, 所以将 $G_{1}$ 与 $G_{6}$ 合并成一个新类, 记作 $G_{7}=\\left\\{x_{1}, x_{3}, x_{5}\\right\\}$ 。\n\n(4) 计算 $G_{7}$ 与 $G_{2}, G_{4}$ 之间的最短距离:\n\n$$\nD_{72}=5, \\quad D_{74}=5\n$$\n\n又注意到\n\n$$\nD_{24}=4\n$$\n\n显然, 其中 $D_{24}=4$ 最小, 所以将 $G_{2}$ 与 $G_{4}$ 合并成一个新类, 记作 $G_{8}=\\left\\{x_{2}, x_{4}\\right\\}$ 。\n\n(5) 将 $G_{7}$ 与 $G_{8}$ 合并成一个新类, 记作 $G_{9}=\\left\\{x_{1}, x_{2}, x_{3}, x_{4}, x_{5}\\right\\}$, 即将全部样本聚成一类, 聚类终止。\n\n上述层次聚类过程可以用图 14.2 所示的层次聚类图表示。\n\n\\begin{center}\n\\includegraphics[max width=\\textwidth]{2024_03_13_690a9c6ba63c19ff9106g-05}\n\\end{center}\n\n图 14.2 层次聚类图\n\n\\section*{$14.3 k$ 均值聚类}\n$k$ 均值聚类是基于样本集合划分的聚类算法。 $k$ 均值聚类将样本集合划分为 $k$ 个子集，构成 $k$ 个类, 将 $n$ 个样本分到 $k$ 个类中, 每个样本到其所属类的中心的距离最小。每个样本只能属于一个类, 所以 $k$ 均值聚类是硬聚类。下面分别介绍 $k$ 均值聚类的模型、策略、算法,讨论算法的特性及相关问题。"
    },
    {
        "id": "chatcmpl-93ywDzm6x9U9IOgnMYu3j6B3cSrQh",
        "choices": [
            {
                "finish_reason": "stop",
                "index": 0,
                "logprobs": null,
                "message": {
                    "content": "{\n    \"问题1\": \"类 $G_{p}$ 和类 $G_{q}$ 之间的距离有哪些不同的定义？\",\n    \"回答1\": \"类 $G_{p}$ 和类 $G_{q}$ 之间的距离有多种定义，包括最短距离（单连接）、最长距离（完全连接）、中心距离和平均距离。这些定义分别基于样本之间的最短距离、最长距离、中心点之间的距离以及样本之间距离的平均值。\",\n    \"问题2\": \"最短距离或单连接是如何定义的？\",\n    \"回答2\": \"最短距离或单连接定义了类 $G_{p}$ 的样本与类 $G_{q}$ 的样本之间的最短距离为两类之间的距离，即 $D_{p q}=\\text{min}\\big\\big\\big\\big\\big\\big\\big\\big\\big\\big\\big\\big\\big\\big\\big\\big\\big\\big\\big\\big\\big\\big\\big\\big\\big\\big\\big\\big\\big\\big\\big\\big\\big\\big\\big\\big\\big\\big\\big{d_{i j} \\text{ 使得 } x_{i} \\text{ 属于 } G_{p}, x_{j} \\text{ 属于 } G_{q}}$。\",\n    \"问题3\": \"最长距离或完全连接是如何定义的？\",\n    \"回答3\": \"最长距离或完全连接定义了类 $G_{p}$ 的样本与类 $G_{q}$ 的样本之间的最长距离为两类之间的距离，即 $D_{p q}=\\text{max}\\big\\big\\big\\big\\big\\big{d_{i j} \\text{ 使得 } x_{i} \\text{ 属于 } G_{p}, x_{j} \\text{ 属于 } G_{q}}$。\",\n    \"问题4\": \"中心距离是如何定义的？\",\n    \"回答4\": \"中心距离定义了类 $G_{p}$ 与类 $G_{q}$ 的中心 $\\bar{x}_{p}$ 与 $\\bar{x}_{q}$ 之间的距离为两类之间的距离，即 $D_{p q}=d_{\\bar{x}_{p} \\bar{x}_{q}}$。\",\n    \"问题5\": \"平均距离是如何定义的？\",\n    \"回答5\": \"平均距离定义了类 $G_{p}$ 与类 $G_{q}$ 任意两个样本之间距离的平均值为两类之间的距离，即 $D_{p q}=\\frac{1}{n_{p} n_{q}} \\text{sum}_{x_{i} \\text{ 属于 } G_{p}} \\text{sum}_{x_{j} \\text{ 属于 } G_{q}} d_{i j}$。\",\n    \"问题6\": \"层次聚类中聚合聚类和分裂聚类有什么区别？\",\n    \"回答6\": \"层次聚类中，聚合聚类（agglomerative）或自下而上聚类是从每个样本各自分到一个类开始，然后将相距最近的两个类合并，重复此操作直到满足停止条件。而分裂聚类（divisive）或自上而下聚类则是从所有样本分到一个类开始，然后将已有类中相距最远的样本分到两个新的类，重复此操作直到满足停止条件。\",\n    \"问题7\": \"聚合聚类的具体过程是怎样的？\",\n    \"回答7\": \"对于给定的样本集合，聚合聚类开始将每个样本分到一个类；然后按照一定规则，如类间距离最小，将最满足规则条件的两个类进行合并；如此反复进行，每次减少一个类，直到满足停止条件。聚合聚类需要预先确定三个要素：距离或相似度、合并规则和停止条件。\",\n    \"问题8\": \"什么是$k$均值聚类？\",\n    \"回答8\": \"$k$均值聚类是基于样本集合划分的聚类算法。它将样本集合划分为$k$个子集，构成$k$个类，并使每个样本到其所属类的中心的距离最小。由于每个样本只能属于一个类，因此$k$均值聚类属于硬聚类。\",\n    \"问题9\": \"$k$均值聚类需要预先确定哪些要素？\",\n    \"回答9\": \"$k$均值聚类需要预先确定要划分成$k$个子集，构成$k$个类，并且需要确定每个样本到其所属类的中心的距禙最小。因此需要预先确定$k$值、初始中心点和停止条件等要素。\",\n    \"问题10\": \"$k$均值聚类算法的复杂度是多少？\",\n    \"回答10\": \"$k$均值聚类算法的复杂度是$O(n^{2} m)$，其中$n$是样本个数，$m$是样本维数。\"\n}",
                    "role": "assistant",
                    "function_call": null,
                    "tool_calls": null
                }
            }
        ],
        "created": 1710736257,
        "model": "gpt-3.5-turbo-1106",
        "object": "chat.completion",
        "system_fingerprint": "fp_4aaaf0dc94",
        "usage": {
            "completion_tokens": 1451,
            "prompt_tokens": 5322,
            "total_tokens": 6773
        },
        "parameters": {
            "model": "gpt-3.5-turbo-1106",
            "temperature": 0.2,
            "frequency_penalty": 0.15,
            "presence_penalty": 0.15
        }
    }
]