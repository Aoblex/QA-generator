[
    {
        "strategy": "subsection",
        "source": "deeplearning",
        "title": "1.3.2 表示学习",
        "content_length": 1495,
        "content": "Title: 1.3.2 表示学习\nContent:\n要学习到一种好的高层语义表示 (一般为分布式表示), 通常需要从底层特征开始, 经过多步非线性转换才能得到. 深层结构的优点是可以增加特征的重用性, 从而指数级地增加表示能力. 因此, 表示学习的关键是构建具有一定深度的多层次特征表示 [Bengio et al., 2013].\n\n在传统的机器学习中, 也有很多有关特征学习的方法, 比如主成分分析、线性判别分析、独立成分分析等. 但是, 传统的特征学习一般是通过人为地设计一些准则, 然后根据这些准则来选取有效的特征. 特征的学习是和最终预测模型的学习分开进行的,因此学习到的特征不一定可以提升最终模型的性能.\n\n\\section*{1.4 深度学习}\n为了学习一种好的表示, 需要构建具有一定 “深度” 的模型, 并通过学习算法来让模型自动学习出好的特征表示 (从底层特征, 到中层特征, 再到高层特征),从而最终提升预测模型的准确率. 所谓 “深度” 是指原始数据进行非线性特征转换的次数. 如果把一个表示学习系统看作一个有向图结构, 深度也可以看作从输入节点到输出节点所经过的最长路径的长度.\n\n这样我们就需要一种学习方法可以从数据中学习一个 “深度模型”, 这就是深度学习 (Deep Learning, DL ). 深度学习是机器学习的一个子问题, 其主要目的是从数据中自动学习到有效的特征表示.\n\n图1.4给出了深度学习的数据处理流程. 通过多层的特征转换, 把原始数据变成更高层次、更抽象的表示. 这些学习到的表示可以替代人工设计的特征, 从\n\n连续多次的线性转换等价于一次线性转换.\n\n参见第2.6.1节。\n\n深度学习虽然早期主要用来进行表示学习，但后来越来越多地用来处理更加复杂的推理、决策等问题.而避免“特征工程”.\n\n\\begin{center}\n\\includegraphics[max width=\\textwidth]{2024_03_13_b7f820bc184c7846d78fg-026}\n\\end{center}\n\n图 1.4 深度学习的数据处理流程\n\n深度学习是将原始的数据特征通过多步的特征转换得到一种特征表示, 并进一步输入到预测函数得到最终结果. 和 “浅层学习” 不同, 深度学习需要解决的关键问题是贡献度分配问题 (Credit Assignment Problem, CAP) [Minsky, 1961], 即一个系统中不同的组件 (component) 或其参数对最终系统输出结果的贡献或影响. 以下围棋为例, 每当下完一盘棋, 最后的结果要么赢要么输. 我们会思考哪几步棋导致了最后的胜利, 或者又是哪几步棋导致了最后的败局. 如何判断每一步棋的贡献就是贡献度分配问题, 这是一个非常困难的问题. 从某种意义上讲, 深度学习可以看作一种强化学习 (Reinforcement Learning, RL), 每个内部组件并不能直接得到监督信息, 需要通过整个模型的最终监督信息 (奖励)得到, 并且有一定的延时性.\n\n目前, 深度学习采用的模型主要是神经网络模型, 其主要原因是神经网络模型可以使用误差反向传播算法, 从而可以比较好地解决贡献度分配问题. 只要是超过一层的神经网络都会存在贡献度分配问题, 因此可以将超过一层的神经网络都看作深度学习模型. 随着深度学习的快速发展, 模型深度也从早期的 $5 \\sim 10$层增加到目前的数百层. 随着模型深度的不断增加, 其特征表示的能力也越来越强,从而使后续的预测更加容易."
    },
    {
        "id": "chatcmpl-92yCg96LnPtTNx9YJZ24TOEKCGQN2",
        "choices": [
            {
                "finish_reason": "stop",
                "index": 0,
                "logprobs": null,
                "message": {
                    "content": "{\n    \"问题1\": \"为什么表示学习的关键是构建具有一定深度的多层次特征表示？\",\n    \"回答1\": \"表示学习的关键是构建具有一定深度的多层次特征表示，因为深层结构可以增加特征的重用性，从而指数级地增加表示能力。通过多步非线性转换，可以从底层特征开始逐步得到更高层次、更抽象的表示，提高预测模型的准确率。\",\n    \"问题2\": \"传统的特征学习和深度学习的特征学习方法有何不同？\",\n    \"回答2\": \"传统的特征学习一般是通过人为地设计一些准则，然后根据这些准则来选取有效的特征。特征的学习是和最终预测模型的学习分开进行的，因此学习到的特征不一定可以提升最终模型的性能。而深度学习通过构建具有一定深度的模型，通过学习算法来自动学习出好的特征表示，从而提升预测模型的准确率。\",\n    \"问题3\": \"深度学习中的 “深度” 是指什么？\",\n    \"回答3\": \"在深度学习中，“深度”指的是原始数据进行非线性特征转换的次数。如果把一个表示学习系统看作一个有向图结构，深度也可以看作从输入节点到输出节点所经过的最长路径的长度。\",\n    \"问题4\": \"深度学习的主要目的是什么？\",\n    \"回答4\": \"深度学习的主要目的是从数据中自动学习到有效的特征表示，通过多层的特征转换，把原始数据变成更高层次、更抽象的表示。这些学习到的表示可以替代人工设计的特征，从而提升预测模型的准确率。\",\n    \"问题5\": \"深度学习和浅层学习的关键问题有何不同？\",\n    \"回答5\": \"深度学习需要解决的关键问题是贡献度分配问题 (Credit Assignment Problem, CAP)，即一个系统中不同的组件或其参数对最终系统输出结果的贡献或影响。而浅层学习不需要解决这个问题。\",\n    \"问题6\": \"深度学习中的贡献度分配问题是什么？\",\n    \"回答6\": \"贡献度分配问题是指一个系统中不同的组件或其参数对最终系统输出结果的贡献或影响。在深度学习中，需要解决每个内部组件对最终系统输出结果的贡献或影响，这是一个非常困难的问题。\",\n    \"问题7\": \"为什么深度学习可以看作一种强化学习？\",\n    \"回答7\": \"深度学习可以看作一种强化学习，因为每个内部组件并不能直接得到监督信息，需要通过整个模型的最终监督信息（奖励）得到，并且有一定的延时性。这类似于强化学习中智能体通过与环境交互获得奖励来学习。\",\n    \"问题8\": \"为什么深度学习采用神经网络模型？\",\n    \"回答8\": \"深度学习采用神经网络模型主要原因是神经网络模型可以使用误差反向传播算法，从而可以比较好地解决贡献度分配问题。只要是超过一层的神经网络都会存在贡献度分配问题，因此可以将超过一层的神经网络都看作深度学习模型。\",\n    \"问题9\": \"随着深度学习模型深度的增加，会对特征表示和预测产生什么影响？\",\n    \"回答9\": \"随着深度学习模型深度的不断增加，其特征表示的能力也越来越强，从而使后续的预测更加容易。因此，增加模型深度可以提高特征表示的能力，进而提高预测模型的准确率。\",\n    \"问题10\": \"深度学习中的图1.4所示数据处理流程是如何描述深度学习的特征转换过程？\",\n    \"回答10\": \"图1.4描述了深度学习的数据处理流程，通过多层的特征转换，把原始数据变成更高层次、更抽象的表示。这些学习到的表示可以替代人工设计的特征，从而提升预测模型的准确率。\"\n}",
                    "role": "assistant",
                    "function_call": null,
                    "tool_calls": null
                }
            }
        ],
        "created": 1710495106,
        "model": "gpt-3.5-turbo-1106",
        "object": "chat.completion",
        "system_fingerprint": "fp_4aaaf0dc94",
        "usage": {
            "completion_tokens": 1397,
            "prompt_tokens": 3875,
            "total_tokens": 5272
        },
        "parameters": {
            "model": "gpt-3.5-turbo-1106",
            "temperature": 0.2,
            "frequency_penalty": 0.05,
            "presence_penalty": 0.05
        }
    }
]