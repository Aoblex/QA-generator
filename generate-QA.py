import os
os.environ["LANGCHAIN_TRACING_V2"] = "false"
os.environ["http_proxy"] = "http://127.0.0.1:7890"
os.environ["https_proxy"] = "http://127.0.0.1:7890"

from langchain_community.chat_models import ChatCohere
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.messages import SystemMessage, HumanMessage, ChatMessage


# Use cohere model
model = ChatCohere(cohere_api_key="A1c1O5tYigERdYOVc2ZRjvTYFoBbSZT8YfUgRFVM")
statistics_template = ChatPromptTemplate.from_messages([

    ("system",
    """
    你是一名初学统计学的学生，你的任务是根据一段统计学教材中的文本，向老师提出3个统计学相关的题目，并自己给出答案。

    要求:
    1.这些问题必须完全不同，鼓励你从多角度提出多样性的问题；
    2.你的问题需要有一定的深度，需要基于你对文本作出深度思考来给出提问；
    3.问题的答案必须包含在文本中，或者可以根据文本推理出来；
    4.你给出的答案不能过短，必须给出充分的回答；
    5.鼓励你根据文章中的案例举一反三，提出自己的实际案例并用课本中的知识分析出来；
    6.你不能使用课本中的图片或表格描述。
    """),

    ("human",
    """
    根据文本，提出统计学相关问题，并给予解答，以下是参考文本:
    
    <context>
    1.2.1 分类数据、顺序数据、数值型数据按照所采用的计量尺度的不同①,可以将统计数据分为分类数据、顺序数据和数值型数据。
    分类数据(categorical data)是只能归于某一类别的非数字型数据，它是对事物进行分类的结果，数据表现为类别，是用文字来表述的。
    例如，人口按照性别分为男、女两①数据的测量尺度有四种:第一，分类尺度(nominal scale)。
    按照事物的某种属性对其进行的平行的分类，数据表现为类别。
    第二，顺序尺度(ordinal scale)。
    对事物类别顺序的测度，数据表现为有序的类别。
    第三，间隔尺度(interval scale),对事物类别或次序之间间距的测度，没有绝对零点，数据表现为数字。
    第四，比率尺度(ratioscale)。
    对事物类别或次序之间间距的测度，有绝对零点，数据表现为数字
    </context>

    你应当按照以下格式输出你的回答:
    {{
        \"题目\":\"...\",
        \"答案\":\"...\"
    }}
    """),
    
    ("ai",
    """
    [
        {{
            \"题目\": \"在统计学中，为什么要将数据按照计量尺度的不同进行分类，而不是简单地将所有数据都看作是数字型数据？\",
            \"答案\":\"在统计学中，将数据按照计量尺度的不同进行分类是为了更好地理解和分析数据的特性和可操作性。不同的计量尺度反映了数据所具有的不同属性和特征，例如分类数据、顺序数据和数值型数据，它们分别呈现出不同的统计特征和分析方法。通过这样的分类，我们可以针对不同类型的数据采用合适的统计技术和方法，从而更准确地描述数据的含义和进行推断分析。\"
        }},
        {{
            \"题目\":\"在分类数据、顺序数据和数值型数据中，有哪些具体的应用场景或案例可以帮助理解它们之间的差异？\",
            \"答案\":\"分类数据通常用于描述事物的属性或类别，例如性别、民族、学历等，其应用场景包括人口统计学、市场调查等领域；顺序数据则反映了事物的有序关系，如学生的成绩等级、产品的质量等，适用于评价和排序问题；而数值型数据则是以数值形式呈现的数据，可用于测量和计量，如温度、身高、收入等，广泛应用于自然科学、社会科学等各个领域。\"
        }},
        {{
            \"题目\":\"在实际统计分析中，如何确定采用何种计量尺度对数据进行分类，以及如何选择适当的统计方法进行分析？\",
            \"答案\":\"确定采用何种计量尺度对数据进行分类需要考虑数据的性质和研究目的。若数据仅涉及分类或标签，应选用分类尺度；若数据除了分类外还有明显的顺序关系，则选用顺序尺度；若数据是具有等距或等比关系的数值型数据，则可选用间隔尺度或比率尺度。在选择统计方法时，应结合数据类型和研究问题，选择适合的描述统计方法、推断统计方法或模型方法，以确保分析结果的准确性和可靠性。\"
        }}
    ]
    """),

    ("human",
    """
    根据文本，提出统计学相关问题，并给予解答，以下是参考文本:

    <context>
    {context}
    </context>

    你应当按照以下格式输出你的回答:
    {{
       \"题目\":\"...\",
        \"答案\":\"...\"
    }}
   """),
])

chain = statistics_template | model

def generate_question_and_answers(context):
    answer = ""
    for chunk in chain.stream({"context": context}):
        print(chunk.content, end="", flush=True)
        answer += chunk.content
    return answer

def save_answer(filename, answer):
    filepath = os.path.join("answers", filename)
    with open(filepath, "w") as f:
        f.write(answer)

contexts = [
    """司徒顿t分布（Student's t-distribution），简称t 分布，在概率论及统计学中用于根据小样本来估计总体呈正态分布且标准差未知的期望值。若总体标准差已知，或是样本数足够大时（依据中心极限定理渐进正态分布），则应使用正态分布来进行估计。其为对两个样本期望值差异进行显著性测试的学生t检验之基础。学生t 检验改进了Z检验（Z-test），因为在小样本中，Z检验以总体标准差已知为前提，Z检验用在小样本会产生很大的误差，因此必须改用学生t 检验以求准确。但若在样本数足够大（普遍认为超过30个即足够）时，可依据中心极限定理近似正态分布，以Z检验来求得近似值，在总体标准差数未知的情况下，不论样本数量大或小皆可应用t检验。在待比较的数据有三组以上时，因为误差无法被压低，此时可以用方差分析（ANOVA）代替t检验。""",
    """为构造检验的统计量，在方差分析中，需要计算三个误差平方和，它们是总平方和、组间平方和(因素平方和)、组内平方和(误差平方和或残差平方和)。
1)总平方和(sum of squares for total),记为SST。
它是全部观测值x,与总均值的误差平方和，其计算公式为:k 生SST=∑∑(xg-x)2(10.3)i=1 j=1例如，在表10-3中已经计算出x=47.869565。
计算总平方和为:SST=(57-47.869565)2+…+(58-47.869565)2=4164.608696它反映了全部23个观测值与这23个观测值平均数之间的差异。
2)组间平方和(sum of squares for factor A),记为SSA,它是各组均值x,(i=1,2,…,k)与总均值x的误差平方和，反映各样本均值之间的差异程度，因此又称为因素平方和。
其计算公式为:SSA=∑n(x?-r)2(10.4)i=1212第10章方差分析例如，根据表10-3的有关结果，计算组间平方和为:4SSA=Zn?(x?-x)2i=1=7×(49-47.869565)2+6×(48-47.869565)2+5×(35-47.869565)2+5×(59—47.869565)2=1456.6086963)组内平方和(sum of squares for error),记为SSE。
它是每个水平或组的各样本数据与其组均值的误差平方和，反映每个样本各观测值的离散状况，因此又称为误差平方和。
该平方和反映了随机误差的大小，其计算公式为:SSE=∑2(xg-x?)2(10.5)i=1 j=1在例10.1中，先求出每个行业被投诉次数与其均值的误差平方和，然后将四个行业的误差平方和加总，即为SSE。""",
]


for i, context in enumerate(contexts):
    answer = generate_question_and_answers(context)
    save_answer(filename=f'context-{i}.json', answer=answer)